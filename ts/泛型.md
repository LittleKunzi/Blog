## 为什么需要泛型

```ts
    const calcArray = (data:any):any[] => {
        let list = []
        for(let i = 0; i < 3; i++){
            list.push(data)
        }
        return list
    }

    console.log(calcArray('a')) // ["a", "a", "a"]
复制代码
```

上述的例子我们发现，在`calcArray`中传任何类型的参数，返回的数组都是`any`类型

由于我们不知道传入的数据是什么，所以返回的数据也为`any的数组`

但我们现在想要的效果是：**无论我们传什么类型，都能返回对应的类型**，针对这种情况怎么办？所以此时`泛型`就登场了

## 泛型语法

我们先用泛型对上面的例子进行改造下，

```ts
const calcArray = <T>(data: T): T[] => { //这里用了<T>来告诉TS我们会用到T这个类型，随后函数的参数传入值为T类型，传出为类型T的数组
  let list = [];
  for (let i = 0; i < 3; i++) {
    list.push(data);
  }
  return list;
};

console.log(calcArray('a')); // ["a", "a", "a"]
```

这时候把鼠标移动到`calcArray`上，就可以看到，传入的是`string`类型。传出的也是`string`类型

```ts
const calcArray: <string>(data: string) => string[]
```

在尖括号<>中的标识符就是会用到的类型。
